/*global require, process, __dirname, module*/
/*jshint globalstrict: true */

"use strict";

var path = require('path'),
    async = require('async'),
    fs = require('fs'),
    readline = require('readline'),
    stream = require('stream'),
	commandLine = require('../command-line'),
    childProcess = require("child_process"),
    files = require('../files'),
    log = require('../log.js'),
    verifyExists = require('../verify'),
    jshint = require('gulp-jshint'),
    gulp;

/**
 * Adds a wildcard glob onto the end of a pathname if it is a directory.
 *
 * scss-lint's exclusions are inconsistent with gitignore which is the same
 * format jshint uses this works around the inconsistency so the same
 * exclusions list can be used.
 *
 * @returns {string}
 */
function addWildCardIfDirectory(pathname) {

    var isExistingDirectory =
        fs.existsSync(pathname) &&
        fs.statSync(pathname).isDirectory();

    if (isExistingDirectory) {
        return path.join(pathname, '/*');
    }

    return pathname;
}

/**
 * Create the SCSS Linter Task making use of the scss-lint command line tool.
 */
function runScssLint() {

    if (!verifyExists.mainSass()) {
        return function(callback) { callback(false, 'No main.scss'); };
    }

    var configPath = __dirname + '/../../config/scss-lint.yml',
        excludePaths = files.getGitIgnorePaths().map(addWildCardIfDirectory),
        sourcePaths = [
            path.join(process.cwd(), '/*.scss'),
            path.join(process.cwd(), '/**/**/*.scss')
        ],
		command = 'scss-lint',
        args = ['--config=' + configPath, '--exclude=' + excludePaths.join(',')].concat(sourcePaths);

    

    //return linterTask(command, args);
}

function pathsToGlob(paths) {
    for (var i = 0; i < paths.length; i++) {
        var path = paths[i];
        paths[i] = '!'+path;
        if (path.charAt(path.length-1) === '/') {
            paths[i] += '**';
        }
    }
    return paths;
}

/**
 * Create the Javsacript Linter Task making use of the JSHint command line
 * tool.
 */
function runJsHint() {

    if(!verifyExists.mainJs()) {
        return function(callback) { callback(false, 'No main.js'); };
    }

    var configPath = __dirname + '/../../config/jshint.json',
        excludePath = path.join(process.cwd(), '/.gitignore'),
        exlcudeFiles = fs.readFileSync(excludePath).toString().split('\n');

    return gulp.src(['**/*.js'].concat(pathsToGlob(exlcudeFiles)))
            .pipe(jshint(configPath))
            .pipe(jshint.reporter('default'));
}

module.exports = function(_gulp) {
    gulp = _gulp;

    return {
        runJsHint: runJsHint,
        run: function(callback) {

            // The run method should be a function requiring a single callback argument,
            //  which accepts an (error, result) argument list.
            var verifierTasks = [
          //       {
                //  name: 'scss-lint',
                //  run: runScssLint(),
                //  // transformOutput: function(output) {
                //  //  var lines = output.split('\n');
                //  //  if (lines.length) {
                //  //      return lines.map(function(line) {
                //  //          return line.replace(path.join(process.cwd(), path.sep), '');
                //  //      }).join('\n') + '\n' + lines.length + ' errors\n';
                //  //  }
                //  //  return '';
                //  // }
                // },
                {
                    name: 'jshint',
                    run: runJsHint
                }
            ];

            /**
             * For each error output an error message.
             *
             * @params {Array} taskErrors An array of errors generated by tasks.
             */
            function outputResults(taskErrors) {
                taskErrors.forEach(function(taskError) {
                    log.primary(taskError.name);
                    log.primaryError(taskError.stdout);
                });
            }

            // COMPLEX: This needs some explaining:
            //   In order to run all the verifier tasks and aggregate all errors,
            //   we need to perform some trickery to accumulate errors as results. By
            //   default the async library halts as soon an error is encountered.
            //   This could potentially cause problems where pedantic linting errors
            //   could be hide more sinister errors in other linter tasks.
            //
            //   To prevent this behaviour, `map` is called using a callback which wraps
            //   errors generated by the task in a new object which is then
            //   passed as a result rather than an error to the callback expected by
            //   the async library.
            //
            //   The final callback should always be called with an `errors` array
            //   (which is empty if no errors occurred). This callback should never
            //   see the error object in its first argument.
            async.map(verifierTasks, function(task, mapCallback) {
                
                task.run();

            }, function(err, errors) {
                // Remove false values (as they were successful tasks)
                var errors = errors.filter(function(error) { return !!error; });
                outputResults(errors);
                callback(errors.length, errors);
            });
        }
    }
}
